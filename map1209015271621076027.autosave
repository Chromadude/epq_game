import java.util.Collections;
import java.lang.Runnable;


class TestMap extends State{
  TestMap(){
    addElement("map", new Map());
  }
}


class Map extends Element{
  int[][] map;
  int mapWidth;
  int mapHeight;
  int numOfGroundTypes;
  int numOfGroundSpawns;
  int waterLevel;
  int initialSmooth;
  int completeSmooth;
  int mapXOffset;
  int mapYOffset;
  int elementWidth;
  int elementHeight;
  int[] mapSpeed = {0,0};
  PImage buffer;
  PImage secondBuffer;
  int startX;
  int startY;
  int bufferX;
  int bufferY;
  float scale;
  int moveSpeed;
  boolean handlingBuffer = false;
  
  Map(){
    mapWidth = 250;
    mapHeight = 250;
    numOfGroundTypes = 3;
    numOfGroundSpawns = 15;
    waterLevel = 1;
    initialSmooth = 7;
    completeSmooth = 5;
    elementWidth = width/2;
    elementHeight = height/2;
    mapXOffset = 0;
    mapYOffset = 0;
    moveSpeed = 64;
    scale = 64; // pixels per block
    buffer = createImage(elementWidth*5, elementHeight*5, RGB);
    secondBuffer = createImage(elementWidth*5, elementHeight*5, RGB);
    generateMap();
  }
  void zoom(){
    
  }
  class MapBufferUpdater implements Runnable {
    private Thread t;
    int tempMapXOffset;
    int tempMapYOffset;
    float tempScale;
    int startX;
    int startY;
    PImage secondBuffer;
    MapBufferUpdater (){
      tempMapXOffset = mapXOffset;
      tempMapYOffset = mapYOffset;
      tempScale = scale;
      secondBuffer = buffer.copy();
    }
    public void run() {
      startX = (tempMapXOffset/elementWidth - 1) * elementWidth;
      startY = (tempMapYOffset/elementHeight - 1) * elementHeight;
      PImage[] tempImages = new PImage[numOfGroundTypes];
      for (int i=0; i<3; i++){
        tempImages[i] = tileImages[i].copy();
        tempImages[i].resize(ceil(tempScale), ceil(tempScale));
      }
      for (int y = int(startY/tempScale); y<int((startY+elementHeight*5)/tempScale);y++){
        for (int x = int(startX/tempScale); x<int((startX+elementWidth*5)/tempScale);x++){
          if(x>=0&&y>=0&&x<mapWidth&&y<mapHeight){
              secondBuffer.copy(tempImages[map[y][x]-1], 0, 0, int(tempScale), int(tempScale), int(x*tempScale-(startX)), int(y*tempScale-(startY)), int(tempScale), int(tempScale));
          }
        }
      }
      buffer = secondBuffer.copy();
      bufferX = int(tempMapXOffset/elementWidth-1)*elementWidth;
      bufferY = int(tempMapYOffset/elementHeight-1)*elementHeight;
      handlingBuffer = false;  
    }
    public void start () {
      if (t == null) {
         t = new Thread (this);
         t.start ();
      }
   }
  }
  void handleBufferIfNeeded(int lastX, int lastY){
    handlingBuffer = true;
    if(int(mapXOffset/elementWidth)!=int(lastX/elementWidth)||int(mapYOffset/elementHeight)!=int(lastY/elementHeight)){
      new MapBufferUpdater().start();
    } 
  }
  
  void mouseEvent(String eventType, int button){
    if (eventType == "mouseClicked"){
      if (button == LEFT){
        scale *= 1.25;
      }
      if (button == RIGHT){
        scale *= 0.8;
      }
      zoom();
    }
    else {
      if (eventType=="mouseDragged"){
        int tempX = mapXOffset;
        int tempY = mapYOffset;
        mapXOffset -= mouseX-startX;
        mapYOffset -= mouseY-startY;
        putInBounds();
        handleBufferIfNeeded(tempX, tempY);
        startX = mouseX;
        startY = mouseY;
      }
      if (eventType == "mousePressed"){
        startX = mouseX;
        startY = mouseY;
      }
    }
  }
  void keyboardEvent(String eventType, int _key){
    if (eventType == "keyPressed"){
      if (_key == 'a'&&mapSpeed[0]>-1){
        mapSpeed[0] -= moveSpeed;
      }
      if (_key == 's'&&mapSpeed[1]<1){
        mapSpeed[1] += moveSpeed;
      }
      if (_key == 'd'&&mapSpeed[0]<1){
        mapSpeed[0] += moveSpeed;
      }
      if (_key == 'w'&&mapSpeed[1]>-1){
        mapSpeed[1] -= moveSpeed;
      }
    }
    if (eventType == "keyReleased"){
      if (_key == 'a'&&mapSpeed[0]<0){
        mapSpeed[0] += moveSpeed;
      }
      if (_key == 's'&&mapSpeed[1]>0){
        mapSpeed[1] -= moveSpeed;
      }
      if (_key == 'd'&&mapSpeed[0]>0){
        mapSpeed[0] -= moveSpeed;
      }
      if (_key == 'w'&&mapSpeed[1]<0){
        mapSpeed[1] += moveSpeed;
      }
    }
  }
  int[][] smoothMap(int distance, int firstType){
    ArrayList<int[]> order = new ArrayList<int[]>();
    for (int y=0; y<mapHeight;y++){
      for (int x=0; x<mapWidth;x++){
        order.add(new int[] {x, y});
      }
    }
    Collections.shuffle(order);
    int[][] newMap = new int[mapHeight][mapWidth];
    for (int[] coord: order){
      int[] counts = new int[numOfGroundTypes+1];
      for (int y1=coord[1]-distance+1;y1<coord[1]+distance;y1++){
       for (int x1 = coord[0]-distance+1; x1<coord[0]+distance;x1++){
         if (y1<mapHeight&&y1>=0&&x1<mapWidth&&x1>=0){
           counts[map[y1][x1]]+=1;
         }
       }
      }
      int highest = map[coord[1]][coord[0]];
      for (int i=firstType; i<=numOfGroundTypes;i++){
        if (counts[i] > counts[highest]){
          highest = i;
        }
      }
      newMap[coord[1]][coord[0]] = highest;
    }
    return newMap;
  }
  
  
  void generateMap(){
    map = new int[mapHeight][mapWidth];
    for(int y=0; y<mapHeight; y++){
      map[y][0] = 1;
      map[y][mapWidth-1] = 1;
    }
    for(int x=1; x<mapWidth-1; x++){
      map[0][x] = 1;
      map[mapHeight-1][x] = 1;
    }
    for(int i=0;i<numOfGroundSpawns;i++){
      int type = (int)random(numOfGroundTypes)+1;
      int x = (int)random(mapWidth-2)+1;
      int y = (int)random(mapHeight-2)+1;
      map[y][x] = type;
      // Water will be type 1
      if (type==1){
        for (int y1=y-waterLevel+1;y1<y+waterLevel;y1++){
         for (int x1 = x-waterLevel+1; x1<x+waterLevel;x1++){
           if (y1 < mapHeight && y1 >= 0 && x1 < mapWidth && x1 >= 0)
             map[y1][x1] = type;
         }
        }
      }
    }
    ArrayList<int[]> order = new ArrayList<int[]>();
    for (int y=1; y<mapHeight-1;y++){
      for (int x=1; x<mapWidth-1;x++){
        order.add(new int[] {x, y});
      }
    }
    Collections.shuffle(order);
    for (int[] coord: order){
      int x = coord[0];
      int y = coord[1];
      while (map[y][x] == 0){
        int direction = (int) random(8);
        switch(direction){
          case 0:
            x= max(x-1, 0);
            break;
          case 1:
            x = min(x+1, mapWidth-1);
            break;
          case 2:
            y= max(y-1, 0);
            break;
          case 3:
            y = min(y+1, mapHeight-1);
            break;
          case 4:
            x = min(x+1, mapWidth-1);
            y = min(y+1, mapHeight-1);
            break;
          case 5:
            x = min(x+1, mapWidth-1);
            y= max(y-1, 0);
            break;
          case 6:
            y= max(y-1, 0);
            x= max(x-1, 0);
            break;
          case 7:
            y = min(y+1, mapHeight-1);
            x= max(x-1, 0);
            break;
        }
      }
      map[coord[1]][coord[0]] = map[y][x];
    }
    map = smoothMap(initialSmooth, 2);
    map = smoothMap(completeSmooth, 1);
    handleBufferIfNeeded(elementWidth*5, 0);
  }
  
  void putInBounds(){
    mapXOffset = min(max(mapXOffset, 0), ceil(mapWidth*scale-elementWidth));
    mapYOffset = min(max(mapYOffset, 0), ceil(mapHeight*scale-elementHeight));
  }
  
  void draw(){
    println("4:"+deltatime());
    if (mapSpeed[0]!=0||mapSpeed[1]!=0){
      int tempX = mapXOffset;
      int tempY = mapYOffset;
      mapXOffset += mapSpeed[0];
      mapYOffset += mapSpeed[1];
      putInBounds();
      if(!handlingBuffer){
        handleBufferIfNeeded(tempX, tempY);
      }
    }
    println("1:"+deltatime());
    image(buffer.get(0, 0, mapXOffset-bufferX+elementWidth, mapYOffset-bufferY+elementHeight), xOffset-mapXOffset+bufferX, yOffset-mapYOffset+bufferY, mapXOffset-bufferX+elementWidth, mapYOffset-bufferY+elementHeight);
    println("2:"+deltatime());
    //image(buffer, width/2, 0, width/2, width/2);
    println("3:"+deltatime());
  }
}